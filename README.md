# Battleship
> Play against the computer to try to sink its ships before it sinks yours!

![](https://i.ibb.co/JcF8rft/slideshow4.png)

I created this version of Battleship in 1 week using vanilla JavaScript, DOM Manipulation, HTML5 and CSS3. Battleship has always been one of my favorite games. My friends and I would draw grids on paper and play over skype. This game is my first ever solo coding project and was built three weeks into my _[General Assembly](https://generalassemb.ly/)_ Software Engineering Immersive course. 

You can play the game _[here](https://astara303.github.io/sei-project-1/)_.

## Tools and Skills

- JavaScript
- HTML5
- CSS3
- GitHub

I utilized DOM manipulation to alter CSS classes and run my script. These tools enabled me to easily alter classes and text, or detect elements by their class.

This game required a lot of planning, and breaking problems down into their smallest parts. I built two grids of divs, each in a 10x10 formation, where the game plays out.

I split the game into two stages: Set-Up and Missile Fire. Both stages have two phases: one for the player, and one for the computer, as I needed to allow for player choice, and to make all the choices for the computer.

Event listeners match the user's clicks to the corresponding grid squares.

Arrays and objects store information about which grids have been fired at, which grids hold ships, and boolean values on whether a ship is sunk.

The game works on mobile.

<img src="https://i.imgur.com/FN27P1T.png">

## Usage

The game is split into two stages: Set-Up and Missile-Fire.

  __Set-Up Stage:__
  1. When the page is loaded, the computer's four ships auto-generate to random positions on the "radar" grid.
  2. The player can place their four ships by clicking on any chosen grid squares on the "your map" grid.
  3. The player cannot start firing at the radar screen until all four of their ships have been placed.

  __Missile-Fire Stage:__
  1. The player always takes the first turn by clicking on the "radar" grid.
  2. The computer will immediately return fire by targeting a square on the player's "map" grid.
  3. "MISS", "HIT", and "SUNK" all display differently on the grid so that the player can keep track of where they should click next, and how many of their ships have been hit or sunk.
  4. When all of the player's ships have been sunk, the computer has won, or vice versa, and the game is over.

_For more information on the game Battleship, please refer to the [Wiki](https://en.wikipedia.org/wiki/Battleship_(game))._

## Functionality

In this section I discuss the functionality that makes the game work (and importantly, fun to play, and possible to lose).

- The computer's ships are automatically placed on the radar grid when the page is loaded. They will never generate off the grid nor intersect. They may be generated horizontally or vertically.

- The player chooses where to place their ships by clicking on the grid and the corresponding ship color appears.

- The player cannot start firing at the radar screen until all of their ships have been placed.

- Every time the user FIREs, the computer FIREs back automatically.

- The computer randomly targets squares on the player's grid and will never HIT the same square twice. This is because their HITs are stored in an array that is referenced during the random firing function.

- If the computer detects a HIT, I've written a targeted fire function that will target nearby grid squares, and update the "last hit" square to continue to HIT surrounding squares as the function works its way down the ship.

Targeted fire:
```
function targetedFire() {
    if (lastHit === '') {
      return
    } else if (!computerMissiles.includes(lastHit - 1) && (lastHit - 1) % width > 0) {
      console.log('trying to generate intelligent fire', lastHit - 1)
      if (playerShip1.location.includes(lastHit - 1)) {
        console.log('targeted hit')
        playerGridCells[lastHit - 1].classList.add('hit')
        computerMissiles.push(lastHit - 1)
        checkSunk()
        if (playerShip1.isSunk) {
          console.log('ship sunk. resetting lastHit')
          lastHit = ''
        } else {
          console.log('ship hit but not sunk. updating last hit')
          lastHit = (lastHit - 1)
        }
```

- When a player or computer has HIT all the squares of a ship, that ship displays as SUNK.

- The CSS classes determine whether a grid is empty, a MISS (filled with a wave), a HIT (filled with an explosion), or SUNK (filled with a skull and crossbones).

- When the player or computer has won, text will display above the grids to congratulate the winner. This is generated by a checkWinner() function that is called whenever a ship is sunk.

## Successes

I am most proud of the automated computer player logic that I wrote. [Codewars](https://www.codewars.com/) had prepared me well for this, teaching me that there is a method or function that can pass any test if you find the right way to write it. And I had a lot of tests to pass: The ships could not generate off the grid, they could not intersect, and I wanted them to generate horizonallty or vertically.

__Starting Point of the ship__

First, I generated a random number between 0-99. This would be the starting point of a ship, because the 10x10 grids I built each have a grid square with an index of 0-100 in the array that holds the divs and creates the grid. 

```
 function createNumber() {
    return Math.floor(Math.random() * 100)
  }
```

__Generating the Ship Placement__

Please see the Challenges section for more information about generating the ships on the grid.

__Ships Do Not Intersect__

I needed to make sure the ships weren't intersecting. I wrote the checkForOverlap function, which is called when a ship is being built and takes the ship being built, and previously built ships, as arguments to make sure no grid numbers are repeated. 

  ```
  function checkForOverlap(arr1, arr2) {
      return arr1.some(item => arr2.includes(item))
  }
  ```

The grids that have been assigned ship classes are saved in arrays on the ship object, so we may check them for overlapping before the ship is placed. If the ship overlapped, the build function was called again until the ship found a safe placement.

__Horizontal or Veritical Ships__

For most of development my ships were only generating horizontally. I understood the math of generating them vertically: instead of adding 1 or subtracting 1 to the current index to create length, I must add 10 or subtract 10 to create height. But I was stuck on how to randomly generate horizontal AND vertical ships in any given game. The solution was so easy. The clue is in the name: RANDOMly generate. So I used Math.random to generate a 50/50 chance for a true or false. Based on this, a ship would call either the generateHorizontally or generateVertically function.

```
  function coinFlip() {
    return Math.random() < 0.5
  }
```

```
function ship1Vertical() {
    const ranNum = createNumber()
    if (ranNum + width < width * width && ranNum + (width * 2) < width * width) {
      console.log('ship1 chose to add to the bottom of', ranNum)
      computerShip1.location.push(ranNum)
      computerShip1.location.push(ranNum + width)
      if (checkForOverlap(computerShip1.location, allComputerShips)) {
        computerShip1.location = []
        ship1Vertical()
      } else {
        computerGridCells[ranNum].classList.add('computerShip1')
        computerGridCells[ranNum + width].classList.add('computerShip1')
        allComputerShips.push(ranNum)
        allComputerShips.push(ranNum + width)
        computerShip1.isPlaced = true
      }
    } else if (ranNum - width >= 0 && ranNum - (width * 2) >= 0) {
      console.log('ship1 chose to add to the top of', ranNum)
      computerShip1.location.push(ranNum)
      computerShip1.location.push(ranNum - width)
      if (checkForOverlap(computerShip1.location, allComputerShips)) {
        computerShip1.location = []
        ship1Vertical()
      } else {
        computerGridCells[ranNum].classList.add('computerShip1')
        computerGridCells[ranNum - width].classList.add('computerShip1')
        allComputerShips.push(ranNum)
        allComputerShips.push(ranNum - width)
        computerShip1.isPlaced = true
      }
    } else {
      computerShip1.location = []
      ship1Vertical()
    }
  }
```

## Challenges

__Ships Generating Off-Grid__

In order to achieve this effect I used math to determine if the random number I generated was far enough from the left or right of the grid, that I could then tell the ship to add the required amount of squares to their ship. For example:
  Ship 2's random number is 20. This means the square is 3 rows down and two from the left. This means that you can add length horizontally to the right, but not to the left.

Ships were still generating off the grid, however. I realised that, in the way I was hardcoding the math, this meant that I had to manually check that every square had room to be added to the grid from that random number. This created some pretty long lines of math for the longer ships:

```
else if (ranNum - width >= 0 && ranNum - (width * 2) >= 0 && ranNum - (width * 3) >= 0 && ranNum - (width * 4) >= 0 && ranNum - (width * 5) >= 0)
```

Now I would definitely use mapping, filtering, and reducing to cut down on the hard-coded math.

__Forgetful Targeted Fire:__

The computer does make targeted fire against a player's ship when it registers a HIT, but if the HIT is detected in the middle of a ship, the computer will only filter through the squares in one direction, reverting to random fire again once it reaches the end of a ship. I am storing the "last hit" square in a variable, and would need to insert the first detected "last hit" variable if the computer reaches the end of a ship but the ship in question has not been SUNK.

Targeted fire "forgetting" to check the other side of the ship:

<img src="https://i.ibb.co/XSxZcdx/Screenshot-2020-03-28-at-10-25-56.png" width="250" height="250">

I am proud that I made the computer a bit smarter, and it is definitely possible to lose. But this logic could be even smarter.

__Clear Grid Did not Clear Grid__

I wrote a 'clear grid' function to completely erase the grid contents by targeting and removing all classes from the grids. This did not execute properly as a "clear", so I used a "refresh page" shortcut instead. I would definitely update this to properly function.

## Key Learnings

- Break up large functions into smaller, reuseable parts.
  - Some logic needed to be resused, so I would make it its own function with a name that would make sense to someone reading my code. Then use this function within another function to make the actions quite easy to follow. For example, after every succesful HIT, I would check to see if the ship had been SUNK:

  ```
  function checkSunk() {
    if (computerShip1.location.every(l => computerGridCells[l].classList.contains('hit'))) {
      computerShip1.location.forEach(l => {
        computerGridCells[l].classList.remove('hit')
        computerGridCells[l].classList.add('sunk')
        computerShip1.isSunk = true
        checkWinner()
      })
    }
  ```

  checkSunk() also includes the checkWinner() function to see if all a player's ships have been SUNK.

- Using if/else statements, you can prepare for any eventuality.
  - I love that I could tell my functions to test ship placement, and if they encounter another ship, generate a new random number and try again. It's these simple, smooth operations of functions that make me so excited to solve problems with code.

- Use booleans to trigger yes/no options or 50/50 chances.
  - When first learning JavaScript I really didn't understand the use for booleans or why they existed. Creating this game showed me how useful they really are.

## Needs Improvement

In this section I describe what needs some work in order for the game to be even better.

- When the user is placing their ships square by square on the map grid, it is possible not to place the squares next to each other. To fix this, I could have the player place multiple squares at one when the corresponsing sized ship is chosen, or next to be placed.

<img src="https://i.imgur.com/gpSduPG.png" width="250" height="250">

- If the player clicks a square they have already clicked, the computer still fires back. This could be frustrating to the player. The computer never repeats fire because I store every previous hit in an array, so I could do something similar for the player where previously clicked grid squares are checked for classes before the computer is allowed to fire.

- I haven't managed to make the computer's auto-generated ships place themselves at least one grid square apart, so sometimes they sit side-by-side. The rules in my house were that is allowed, but I know some people consider it a rule of Battleship to not allow ships to sit next to each other. I could make part of the placement function to detect nearby grids for ships.

- The code is _very_ hard-coded. It works well and I'm proud of it but now that I have more experience with functional programming and map, filter, and reduce, I would take advantage of that and refactor the code.

- I only used about half a day to do the CSS, so I'd like a more interactive design. I could add animations and sounds to the HIT explosions, or sounds when a ship is sunk. There could be a "start game" page with a button that hid the rest of the page on "display: none" until a boolean or class triggers the page be shown when the button is pressed.

## Hello!

I'm an avid enjoyer of JavaScript. I would be so happy to discuss this project, or any of your JavaScript projects with you.
I am a big gaming nerd so feel free to share your games with me!
If you'd like to see more of my work or get to know a bit more about me, please check out my portfolio:

_[My Portfolio](https://astara303.github.io/portfolio/)_

Thank you for reading!